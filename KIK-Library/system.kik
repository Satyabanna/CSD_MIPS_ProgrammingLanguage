// system.kik
// Minimal system module for Linux terminals.
// - Provides: enableRawMode(), disableRawMode(), readKey(), clearScreen(),
//             moveCursor(row,col), hideCursor(), showCursor(), getWindowSize(&r,&c), exit(code)
// - Works in two modes:
//    * fallback (pure KIK): uses ANSI escapes and input() (line mode)
//    * helper mode: if helper binary 'kik_term_helper' is present, uses it for raw key reads & size.

import "io.kik";
import "file.kik";   // optional, used if popen-style calls exist
import "string.kik";

constant str HELPER_PATH = "/usr/local/bin/kik_term_helper"; // adjust if you place helper elsewhere

// Internal state
bool __raw_mode_enabled = false;
bool __helper_available = false;

// Try to detect helper availability at module init
void __detect_helper() {
    // This tries to open the helper; if your file.kik provides file_exists or system/run, adapt this.
    // We'll attempt to run "which" as a portable test; if your KIK has no shell-run, leave helper disabled.
    if (file_exists(HELPER_PATH)): {
        __helper_available = true;
    } else: {
        // Try "which" fallback
        str whichOut = run_command("which kik_term_helper"); // run_command => replace if your file.kik uses another name
        if (whichOut.length() > 0): {
            __helper_available = true;
        } else: {
            __helper_available = false;
        }
    }
}

// ---------- Basic ANSI helpers (pure-KIK) ----------
void clearScreen() {
    // Clear entire screen and move cursor to home
    output("\x1b[2J");
    output("\x1b[H");
}

void moveCursor(int row, int col) {
    // row and col are 0-based in the editor code; convert to 1-based for terminal
    int r = row + 1;
    int c = col + 1;
    str s = "\x1b[" + int_to_str(r) + ";" + int_to_str(c) + "H";
    output(s);
}

void hideCursor() {
    output("\x1b[?25l");
}

void showCursor() {
    output("\x1b[?25h");
}

// ---------- Window size (fallback) ----------
void getWindowSize(int* rows, int* cols) {
    // Preferred: ask helper. Fallback: use environment or default.
    if (!__helper_available) {
        // Try to use stty size via run_command if available
        str out = run_command("stty size 2>/dev/null");
        if (out.length() > 0) {
            // stty output: "<rows> <cols>\n"
            // parse
            int space_idx = out.find(" ");
            if (space_idx >= 0) {
                str rs = out.substr(0, space_idx);
                str cs = out.substr(space_idx + 1, out.length() - space_idx - 1);
                *rows = str_to_int(rs);
                *cols = str_to_int(cs);
                return;
            }
        }
        // fallback defaults
        *rows = 24;
        *cols = 80;
        return;
    } else {
        // Use helper: run helper with argument "size" and parse "rows cols\n"
        str out = run_command(HELPER_PATH + " size");
        if (out.length() > 0) {
            int space_idx = out.find(" ");
            if (space_idx >= 0) {
                str rs = out.substr(0, space_idx);
                str cs = out.substr(space_idx + 1, out.length() - space_idx - 1);
                *rows = str_to_int(rs);
                *cols = str_to_int(cs);
                return;
            }
        }
        // fallback
        *rows = 24;
        *cols = 80;
        return;
    }
}

// ---------- Raw mode and readKey ----------
void enableRawMode() {
    if (__raw_mode_enabled) { return; }
    if (__helper_available) {
        // Tell the helper to enable raw mode (helper keeps state per-process)
        run_command(HELPER_PATH + " raw_enable");
        __raw_mode_enabled = true;
        return;
    } else {
        // No helper: can't switch terminal into true raw mode from pure-KIK reliably.
        // We mark raw-mode as not-fully-supported; editor will fall back to line mode.
        __raw_mode_enabled = false;
        E.status_msg = "Warning: Raw mode unavailable; using line input.";
        return;
    }
}

void disableRawMode() {
    if (!__raw_mode_enabled) { return; }
    if (__helper_available) {
        run_command(HELPER_PATH + " raw_disable");
        __raw_mode_enabled = false;
    }
}

// readKey(): returns integer representing a single byte or special codes for arrows.
// If helper exists, use it. Otherwise, read a full line via input() and return first char.
int readKey() {
    if (__helper_available) {
        str out = run_command(HELPER_PATH + " readkey"); // returns either single byte or "ESC[<seq>"
        if (out.length() == 0) { return 0; }
        // If out starts with ESC sequences, return a negative code for arrows
        if (out[0] == '\x1b') {
            // handle common arrow sequences
            if (out.length() >= 3 && out[1] == '[') {
                char c = out[2];
                if (c == 'A') { return -1000 - 1; } // up
                if (c == 'B') { return -1000 - 2; } // down
                if (c == 'C') { return -1000 - 3; } // right
                if (c == 'D') { return -1000 - 4; } // left
            }
            return ord(out[0]);
        } else {
            return ord(out[0]);
        }
    } else {
        // fallback: use input() (blocking line) and return first character
        str line = input();
        if (line.length() == 0) { return 0; }
        return ord(line[0]);
    }
}

// ---------- Exit wrapper ----------
void exit(int code) {
    // disable raw mode if needed
    if (__raw_mode_enabled) {
        disableRawMode();
    }
    // try to run 'exit' command or simply call system exit if available
    run_command("exit " + int_to_str(code));
    // As fallback, just loop forever (should not reach).
    while (true): {}
}

// ---------- Utilities used above (implementations depend on your file.kik) ----------
// If your runtime provides the following helpers, system.kik will use them.
// Otherwise, implement analogues in your file.kik or adapt these functions.

bool file_exists(str path) {
    // try to open; file.kik must provide open/read or similar
    // fallback: try run_command("test -x <path> && echo ok")
    str out = run_command("test -x " + path + " && echo ok || true");
    return out.trim() == "ok";
}

// run_command(cmd) should execute a shell command and return stdout as a string.
// If your file.kik exposes a different function name, replace calls above accordingly.
// Here we declare a placeholder that must be implemented by your runtime.
str run_command(str cmd) {
    // Placeholder: if your KIK has direct popen or exec wrappers, map them here.
    // For now, we fall back to input() prompt as a last resort (not ideal).
    output("SYSTEM: run_command not implemented. Tried: " + cmd);
    return "";
}

// String & int helpers (assume string.kik provides these; otherwise implement)
int str_to_int(str s) {
    // naive implementation
    int res = 0;
    int i = 0;
    if (s.length() > 0 && s[0] == '-') { i = 1; }
    for (; i < s.length(); i = i + 1: ) {
        res = res * 10 + (s[i] - '0');
    }
    if (s.length() > 0 && s[0] == '-') { res = -res; }
    return res;
}

str int_to_str(int x) {
    // simple converter
    if (x == 0) { return "0"; }
    bool neg = false;
    if (x < 0) { neg = true; x = -x; }
    str s = "";
    while (x > 0) {
        int d = x % 10;
        s = char('0' + d) + s;
        x = x / 10;
    }
    if (neg) { s = "-" + s; }
    return s;
}

// call detection at module load time
__detect_helper();
